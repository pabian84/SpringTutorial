# 위젯 메모리 관리 및 백엔드 로직 분석 보고서

## 1. 위젯 메모리 해제(Cleanup) 로직 분석

가장 리소스를 많이 사용하는 Cesium(3D 지도)과 Three.js(로봇 팔) 위젯을 중심으로 분석한 결과, 전반적으로 **React의 생명주기에 맞춘 해제 로직이 잘 구현**되어 있습니다.

### 1.1 Cesium 위젯 (`CesiumMapViewer.tsx`)
- **분석**: `Resium` 라이브러리의 `<Viewer>` 컴포넌트를 사용하여 내부적으로 Cesium 엔진의 `destroy()`를 호출하도록 설계되어 있습니다.
- **Cleanup 확인**: `useEffect`의 클린업 함수에서 `camera.moveEnd` 이벤트 리스너를 명시적으로 제거(`removeEventListener`)하고 있어 메모리 누수를 방지하고 있습니다.
- **보완 제안**: `viewerRef.current`가 참조하는 원시 Cesium 객체의 다른 이벤트(예: `scene.postRender`)를 추가할 경우에도 반드시 클린업 로직을 포함해야 합니다.

### 1.2 Three.js 위젯 (`RobotArmScene.tsx`)
- **분석**: `@react-three/fiber`를 사용하고 있어, 컴포넌트 언마운트 시 Three.js의 `Scene`, `Camera`, `Renderer` 등이 자동으로 처리(dispose)됩니다.
- **Cleanup 확인**: `Canvas` 컴포넌트가 언마운트될 때 WebGL 컨텍스트를 적절히 정리하므로 큰 누수 위험은 없습니다.
- **보완 제안**: 외부에서 로드하는 GLTF 모델(`customModelUrl`)이 매우 크고 위젯을 자주 껐다 켰다 한다면, `useGLTF.preload`나 수동 캐시 관리(Cache eviction)를 검토해볼 수 있습니다.

### 1.3 지연 로딩 전략 (`DeferredComponent.tsx`)
- **분석**: `requestIdleCallback`과 `requestAnimationFrame`을 사용하여 초기 로딩 시 메인 스레드 부하를 분산하는 전략이 매우 훌륭합니다.
- **효과**: 대시보드 진입 시 모든 위젯이 동시에 렌더링되면서 발생하는 브라우저 프리징(Freezing) 현상을 효과적으로 방지하고 있습니다.

---

## 2. 백엔드 인증 로직 분석 (`AuthController.java`)

사용자님의 우려와 달리, 백엔드 코드 확인 결과 **토큰 만료 시간 계산이 정밀하게 구현**되어 있음을 확인했습니다.

### 2.1 `expiresIn` 계산 로직
- **코드 확인**: `jwtTokenProvider.getTokenRemainingTime(token)`을 통해 토큰의 **실제 남은 시간**을 초 단위로 계산하여 반환하고 있습니다.
- **의의**: 단순히 설정상의 최대 시간(예: 30분)을 주는 것이 아니라, 현재 시점 기준의 잔여 시간을 주기 때문에 프론트엔드의 **Proactive Refresh(만료 전 사전 갱신)** 로직이 매우 정확하게 동작할 수 있습니다.

### 2.2 세션 검증
- `/api/auth/refresh` 호출 시 DB에서 `sessionId`를 조회하여 세션 유효성을 한 번 더 검증하므로 보안성이 높습니다.

---

## 3. 종합 의견 및 제안

현재 프로젝트는 **프론트엔드의 리소스 최적화와 백엔드의 정밀한 세션 관리**가 조화롭게 결합된 상태입니다. 기술적으로 큰 결함은 발견되지 않았습니다.

### 추가 제안 사항
1. **Three.js 리소스 해제**: `RobotArmScene`에서 `meshStandardMaterial`이나 `geometry` 등을 수동으로 생성하는 로직이 추가된다면, 해당 객체들에 대해 `dispose()`를 명시적으로 호출하는 패턴을 유지해 주세요.
2. **Dashboard 위젯 관리**: `Dashboard.tsx`에서 일부 위젯에 설정된 `keepMounted: true`는 UX를 위해 메모리를 점유하는 방식입니다. 만약 저사양 기기에서 문제가 된다면, 사용자가 선택적으로 위젯을 끌 수 있는 기능을 추가하여 `Dashboard`에서 해당 컴포넌트 자체를 조건부 렌더링(`{showWidget && <Widget />}`)으로 제거하는 것이 좋습니다.

**결론**: 사용자님의 설계 의도대로 리소스 관리와 인증 동기화가 매우 체계적으로 작동하고 있습니다. 이대로 운영을 지속하셔도 무방할 것으로 판단됩니다.
