# 🛡️ 유령 쿠키 데드락(Ghost Cookie Deadlock) 분석 및 해결 방안

## 1. 문제 현상
사용자가 로그아웃했거나 서버에서 세션이 만료되었음에도 불구하고, 브라우저에 `accessToken` 쿠키가 삭제되지 않고 남아 있어 **로그인이 불가능한 상태**에 빠지는 현상입니다.

### 데드락 루프(Deadlock Loop) 과정
1.  **로그인 시도**: 브라우저에 과거의 `accessToken` 쿠키가 남아 있음.
2.  **백엔드(Login)**: 쿠키를 발견하고 검증함. JWT 자체는 유효(Signature/Expiry OK)하므로 **"이미 로그인됨(409 Conflict)"** 반환.
3.  **프론트엔드**: 409 응답을 받고 "이미 로그인 상태구나" 판단하여 `/dashboard`로 리다이렉트.
4.  **백엔드(Filter)**: 대시보드 진입 시 DB에서 세션을 조회함. **세션이 없으므로 "인증 실패(401)"** 반환.
5.  **프론트엔드**: 401 응답을 받고 다시 `/login`으로 튕김. (1번으로 무한 반복)

---

## 2. 발생 원인
1.  **JWT와 DB 세션의 생명주기 불일치**: JWT 토큰은 브라우저에 물리적으로 존재하지만, 실제 권한의 핵심인 세션은 서버 DB에서 먼저 삭제될 수 있습니다. (관리자 강퇴, 서버 재시작 등)
2.  **로그인 API의 불완전한 검증**: 로그인 시점에 "쿠키가 있는가?"만 따지고 "그 쿠키가 실제 유효한 세션과 연결되어 있는가?"를 DB 레벨에서 확인하지 않기 때문입니다.
3.  **브라우저 세션 쿠키 특성**: `maxAge: -1`로 설정된 쿠키는 브라우저를 완전히 닫기 전까지 메모리에 유지되므로, 비정상 종료 시 "유령"처럼 남게 됩니다.

---

## 3. 완벽한 해결 방안 (Full-Stack)

### 3.1 백엔드: 로그인 API 멱등성 보장 (최종 수문장)
로그인 요청 시 쿠키가 있다면, 단순히 JWT의 유효성만 보지 말고 **실제 DB에 해당 세션이 있는지** 확인해야 합니다.

```java
// UserController.java 수정 제안
if (existingToken != null && jwtTokenProvider.validateToken(existingToken)) {
    Long sessionId = jwtTokenProvider.getSessionId(existingToken);
    // [핵심] DB에서 실제 세션 존재 여부 확인 로직 추가
    boolean isSessionExists = sessionService.exists(sessionId); 

    if (isSessionExists) {
        return ResponseEntity.status(HttpStatus.CONFLICT).body("이미 로그인된 상태입니다.");
    } else {
        // 유령 쿠키 발견: 즉시 삭제 처리 후 로그인을 계속 진행시킴
        ResponseCookie deleteCookie = cookieUtil.deleteCookie("accessToken", isHttps);
        response.addHeader("Set-Cookie", deleteCookie.toString());
        log.warn("유령 쿠키 삭제 완료. 로그인을 새로 진행합니다.");
    }
}
```

### 3.2 프론트엔드: 인증 실패 시 로컬 클린업 강제화
백엔드가 401이나 409를 던질 때, 프론트엔드에서도 기존의 인증 관련 참조(`Ref`, `State`)를 완전히 초기화해야 합니다.

1.  **Axios Interceptor**: 401 에러 발생 시 리다이렉트만 할 게 아니라, `authUtility.resetAuthCheck()`를 명시적으로 호출.
2.  **로그인 시도 전 클린업**: 로그인 버튼을 누르는 시점에 혹시 모를 로컬 상태를 한 번 비우고 요청 전송.

---

## 4. 기대 효과
- **데드락 원천 차단**: 브라우저를 껐다 켜지 않아도 서버가 유령 쿠키를 인지하고 즉시 교체합니다.
- **보안성 향상**: 서버 DB와 브라우저 쿠키 상태가 항상 1:1로 동기화됩니다.
- **사용자 경험(UX)**: 이유를 알 수 없는 로그인 실패 현상이 사라집니다.
