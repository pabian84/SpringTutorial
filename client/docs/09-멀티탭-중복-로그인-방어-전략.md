# 🛡️ 멀티 탭 중복 로그인 방어 전략 분석

## 1. 문제 개요
동일한 브라우저의 여러 탭에서 로그인 페이지를 띄워놓은 경우, 한 탭에서의 로그인 성공이 다른 탭에 즉시 반영되지 않아 발생하는 세션 충돌(Session Conflict) 및 데이터 오염 문제를 해결하기 위한 전략입니다.

### 발생 가능한 시나리오
1.  **Tab 1**: `admin`으로 로그인 성공. (세션 쿠키 생성)
2.  **Tab 2**: 여전히 로그인 페이지. 사용자가 `user_1`으로 로그인 시도.
3.  **충돌**: 서버는 기존 `admin` 세션을 유효하게 유지할지, 새로운 `user_1`으로 덮어쓸지 경합 발생. 브라우저는 `user_1` 쿠키로 업데이트하지만, 서버 내부 상태와 탭 1의 UI가 꼬임.

---

## 2. 산업 표준 대응 방식 (구글, 네이버 등)

### 2.1 실시간 상태 동기화 (BroadcastChannel API)
- **동작**: 한 탭에서 로그인/로그아웃 이벤트 발생 시 브라우저 내 모든 탭에 메시지 전송.
- **장점**: 즉각적인 UI 반응 (새로고침 없이 대시보드 리다이렉트).
- **단점**: 구형 브라우저(IE 등) 미지원 (현재 프로젝트 환경에서는 무관).

### 2.2 스토리지 감시 (StorageEvent)
- **동작**: `localStorage`의 변경 사항을 감시하여 인증 상태 변화 감지.
- **장점**: 구현이 단순하고 모든 모던 브라우저에서 안정적임.
- **단점**: 스토리지 쓰기 작업이 수반됨.

### 2.3 로그인 전 세션 사전 확인 (Pre-emptive Check)
- **동작**: 로그인 요청(POST)을 보내기 직전에 현재 세션 유효성을 API로 선확인.
- **장점**: 서버 리소스를 아끼고 확실한 차단 가능.
- **단점**: 네트워크 요청이 1회 추가됨.

---

## 3. 우리 프로젝트 적용 방안 (제안)

### 전략 1: 탭 간 실시간 동기화 (최우선 권장)
- **대상**: `AuthProvider.tsx`, `authUtility.ts`
- **로직**: 
    - 로그인 성공 시 `BroadcastChannel.postMessage('LOGIN_SUCCESS')` 실행.
    - 로그인 페이지(`location.pathname === '/'`)에 있는 탭이 해당 메시지를 받으면 즉시 대시보드로 이동.

### 전략 2: 로그인 요청 전 세션 잠금 (Double-Lock)
- **대상**: `AuthProvider.tsx` 의 `login` 함수
- **로직**:
    ```typescript
    const login = async (...) => {
      // 로그인 요청 전 최신 세션 상태 확인
      const { authenticated } = await checkAuthStatus(true);
      if (authenticated) {
        showToast('이미 다른 환경에서 로그인되었습니다.', 'info');
        navigate('/dashboard');
        return;
      }
      // ... 이후 실제 로그인 API 호출
    }
    ```

---

## 4. 기대 효과
1.  **무결성**: 브라우저 세션과 서버 세션 간의 유저 정보 불일치를 원천 차단합니다.
2.  **안전성**: 실수로 다른 계정으로 이중 로그인하여 발생하는 보안 사고를 예방합니다.
3.  **UX**: 사용자가 수동으로 새로고침하지 않아도 시스템이 유기적으로 반응하여 대시보드로 안내합니다.
