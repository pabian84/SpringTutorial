# 🛡️ 기기 식별 쿠키(Device ID)를 이용한 세션 재사용 전략

## 1. 개요 및 배경
- **문제**: 브라우저 종료 시 `accessToken`이 삭제되어, 재접속 시 서버가 이를 새로운 기기로 인식하고 매번 **새 세션을 생성**함.
- **결과**: 기기 관리 페이지에 동일 브라우저임에도 불구하고 불필요한 세션 기록이 누적됨.
- **목표**: 동일 브라우저 프로필 재접속 시 기존 세션을 식별 및 재사용하여 데이터 무결성을 확보함.

---

## 2. 핵심 설계: 이중 쿠키 전략 (Dual-Cookie Strategy)

| 구분 | 인증 쿠키 (accessToken) | 기기 식별 쿠키 (deviceId) |
| :--- | :--- | :--- |
| **수명** | 세션 기반 (Max-Age: -1) | 영구적 (Max-Age: 1년) |
| **보안** | HttpOnly, Secure, Strict | HttpOnly, Secure, Strict |
| **역할** | API 호출 권한 부여 | 브라우저 프로필 고유 식별 |
| **특징** | 창을 닫으면 즉시 소멸 | 창을 닫아도 하드디스크에 보존 |

---

## 3. 작동 메커니즘 (Step-by-Step)

### 단계 1: 로그인 요청 (Login Request)
1.  클라이언트는 로그인 시 브라우저에 저장된 모든 쿠키를 서버로 전송합니다.
2.  서버는 요청 쿠키 중 `deviceId`가 존재하는지 확인합니다.

### 단계 2: 세션 식별 및 재사용 (Session Identification)
1.  **신규 기기**: `deviceId`가 없거나 DB에 일치하는 기록이 없는 경우
    - 새 UUID를 생성하여 `deviceId`로 명명.
    - DB 세션 테이블에 `(userId, deviceId)` 쌍으로 새 레코드 생성.
2.  **기존 기기**: `deviceId`가 DB 세션 테이블의 `(userId, deviceId)`와 일치하는 경우
    - **새 레코드를 만들지 않고**, 기존 레코드의 `lastAccessedAt`만 업데이트.
    - 기존 세션 ID를 그대로 사용하여 새로운 `accessToken` 발급.

### 단계 3: 응답 및 저장 (Response)
1.  서버는 응답 헤더(`Set-Cookie`)를 통해 두 쿠키를 모두 내려줍니다.
2.  브라우저는 `deviceId`를 영구 저장소에 기록하여 다음 접속 시 재사용합니다.

---

## 4. 예외 상황 및 보안 대응 (Edge Cases)

### A. 쿠키 수동 삭제 (Flickering Prevention)
- 사용자가 F12로 쿠키를 삭제하면 서버는 이를 신규 기기로 간주하고 새 `deviceId`를 발급합니다. 이는 시스템 오류가 아닌 **"보안 초기화"**로 정상 작동합니다.

### B. 동일 브라우저에서 다른 계정으로 로그인 (User Switch)
- **정책**: 보안을 위해 로그인한 유저 ID가 기존 `deviceId`와 연결된 유저와 다를 경우, 기존 `deviceId`를 폐기하고 새로운 값을 발급합니다.

### C. 프로필 간 격리 (Profile Isolation)
- 브라우저 프로필별로 쿠키 저장소가 물리적으로 분리되어 있으므로, 프로필 1과 프로필 2는 서로 다른 `deviceId`를 가지며 완벽히 격리된 세션을 유지합니다.

---

## 5. 기대 효과
1.  **데이터 무결성**: 기기 관리 리스트가 실제 물리적 접속 환경과 1:1로 일치.
2.  **관리 편의성**: 불필요한 "새 기기 로그인" 알림 감소 및 좀비 세션 누적 방지.
3.  **보안성**: `HttpOnly` 설정을 통해 자바스크립트 기반 탈취(XSS)를 원천 차단.
