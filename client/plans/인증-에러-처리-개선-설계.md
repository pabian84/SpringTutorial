# 인증 에러 처리 개선 설계서

## 1. 문제점 분석

### 1.1 현재 발생 중인 문제

| 문제 | 증상 | 원인 |
|------|------|------|
| **handleVisibilityChange showToast 미출력** | 탭 포커스 시 토스트 메시지가 뜨지 않음 | React 상태 업데이트가 이벤트 핸들러 내에서 즉각적으로 반영되지 않음 |
| **401 에러 시 로그인 페이지 이동 안 함** | showToast만 표시되고 `/`로 리다이렉트되지 않음 | `navigate` 함수가 useEffect 의존성에 없어서 최신 참조가 아님 |
| **인증 상태 불일치** | 서버에서는 세션이 만료되었지만 클라이언트는 인증된 상태로 인식 | 재인증 로직 없이 에러만 처리 |
| **에러 토스트 중복 출력** | 403 에러 시 "접근이 거부되었습니다"가 여러 번 출력 | `isProcessingError` 플래그가 `setTimeout`으로 5초간 유지되어 재처리됨 |

### 1.2 요구사항 정리

```
401/403/404 에러 발생 시 (A006/S001 에러코드 제외):
┌─────────────────────────────────────────────────────────────────┐
│  1. 현재 진행 중인 모든 API 요청 일시정지                         │
│  2. 서버에 인증 상태 다시 확인 (checkAuthStatus)                │
│  3. 인증 결과에 따라:                                            │
│     ├── 인증 OK → 일시정지한 요청 재진행                         │
│     └── 인증 FAIL → 모든 요청 취소 + 로그인 페이지로 이동         │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 아키텍처 설계

### 2.1 전체 흐름도

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              사용자 브라우저                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────────────┐                                                  │
│  │   Axios Interceptor   │                                                  │
│  │   (axiosConfig.ts)    │                                                  │
│  └──────────┬───────────┘                                                  │
│             │                                                              │
│             │ 401/403/404 에러                                             │
│             ▼                                                              │
│  ┌──────────────────────────────────────────────────────────────────┐       │
│  │  handleAuthError() - 인증 에러 공통 처리                           │       │
│  │  • 에러 메시지 결정                                                │       │
│  │  • checkAuthStatus()로 인증 재확인                                 │       │
│  │  • 인증 OK: 요청 재진행                                             │       │
│  │  • 인증 FAIL: 큐 비우고 로그인 페이지로 이동                         │       │
│  └──────────────────────────────────────────────────────────────────┘       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 컴포넌트 책임 분담

| 파일 | 책임 |
|------|------|
| `axiosConfig.ts` | API 에러 포착, `handleAuthError()` 공통 처리, 요청 큐 관리 |
| `AuthProvider.tsx` | `onAuthFailed` callback (`handleLogout`), `onAuthRestored` callback |
| `authUtility.ts` | `checkAuthStatus()` API 호출 (기존 유지) |

### 2.3 상태 관리 플래그

| 플래그 | 역할 |
|--------|------|
| `isProcessingError` | 인증 에러 처리 중복 방지 (401/403/404 통합) |
| `isLoggingOut` | 로그아웃 중복 방지 |

---

## 3. 상세 구현 코드

### 3.1 axiosConfig.ts (완전한 구현)

```typescript
// src/utils/axiosConfig.ts

import axios, { type InternalAxiosRequestConfig, type AxiosError } from 'axios';
import { showToast } from './Alert';
import { resetAuthCheck, checkAuthStatus } from './authUtility';

// ============================================
// 인증 에러 큐 (401/403/404 에러 시 요청 일시정지)
// ============================================
type RetryRequest = {
  config: InternalAxiosRequestConfig;
  resolve: (value: string) => void;
  reject: (error: Error) => void;
};

const authRetryQueue: RetryRequest[] = [];

// ============================================
// 상태 관리 플래그
// ============================================
let isProcessingError = false;  // 인증 에러 처리 중복 방지
let isLoggingOut = false;       // 로그아웃 중복 방지

// ============================================
// Public 엔드포인트 목록
// ============================================
const PUBLIC_ENDPOINTS = [
  '/api/user/login',
  '/api/user/logout',
  '/api/auth/check',
  '/api/sessions/refresh',
];

const isPublicEndpoint = (url: string): boolean => {
  return PUBLIC_ENDPOINTS.some(ep => url.includes(ep));
};

// ============================================
// 인증 에러 공통 처리
// ============================================
const handleAuthError = async (
  status: number,
  errorCode: string | undefined,
  error: AxiosError,
  callbacks: { onAuthFailed: () => void; onAuthRestored: () => void }
): Promise<never> => {
  const { onAuthFailed, onAuthRestored } = callbacks;

  // 에러 메시지 결정
  let errorMessage = '오류가 발생했습니다.';
  if (status === 401) errorMessage = '세션이 만료되었습니다.';
  else if (status === 403) errorMessage = '접근이 거부되었습니다.';
  else if (status === 404) errorMessage = '페이지를 찾을 수 없습니다.';

  showToast(errorMessage, 'error');

  // 인증 상태 재확인
  const authResult = await checkAuthStatus();

  if (authResult.authenticated) {
    // 인증 OK → 요청 재진행
    isProcessingError = false;
    onAuthRestored();
    return axios(authRetryQueue[0]?.config || error.config);
  } else {
    // 인증 FAIL → 로그아웃 처리
    isProcessingError = false;
    resetAuthCheck();

    // 큐에 있는 모든 요청 실패 처리
    authRetryQueue.forEach(({ reject }) => reject(new Error('Session expired')));
    authRetryQueue.length = 0;

    isLoggingOut = true;
    onAuthFailed();

    return Promise.reject(error);
  }
};

// ============================================
// Axios Interceptor 설정
// ============================================
interface InterceptorCallbacks {
  onAuthFailed: () => void;      // 인증 실패 (로그인 페이지로)
  onAuthRestored: () => void;   // 인증 복구 (재연결 등)
}

export const setupAxiosInterceptors = (callbacks: InterceptorCallbacks) => {
  const { onAuthFailed, onAuthRestored } = callbacks;

  axios.defaults.baseURL = '';
  axios.defaults.withCredentials = true;

  // ------------------------------------------
  // 1. 요청 인터셉터
  // ------------------------------------------
  axios.interceptors.request.use(
    async (config: InternalAxiosRequestConfig) => {
      const url = config.url || '';

      // Public 엔드포인트는 통과
      if (isPublicEndpoint(url)) {
        return config;
      }

      // 인증 재확인 후 대기 중인 요청이 있으면 토큰 주입
      if (authRetryQueue.length > 0) {
        return new Promise<string>((resolve, reject) => {
          authRetryQueue.push({
            config,
            resolve: (token: string) => resolve(token),
            reject: (error: Error) => reject(error),
          });
        }).then((token) => {
          if (token && config.headers) {
            config.headers.Authorization = `Bearer ${token}`;
          }
          return config;
        });
      }

      return config;
    },
    (error: AxiosError) => Promise.reject(error)
  );

  // ------------------------------------------
  // 2. 응답 인터셉터
  // ------------------------------------------
  axios.interceptors.response.use(
    (response) => response,
    async (error: AxiosError) => {
      // 네트워크 에러 (응답 없음)
      if (!error.response) {
        return Promise.reject(error);
      }

      const config = error.config as InternalAxiosRequestConfig;
      const url = config?.url || '';
      const status = error.response.status;
      const data = error.response.data as { code?: string };
      const errorCode = data?.code;

      // Public 엔드포인트 에러는 무시
      if (isPublicEndpoint(url)) {
        return Promise.reject(error);
      }

      // 중복 처리 방지
      if (isProcessingError || isLoggingOut) {
        return Promise.reject(error);
      }
      isProcessingError = true;

      // 403 Forbidden (A006 에러코드 제외)
      if (status === 403 && errorCode !== 'A006') {
        return handleAuthError(status, errorCode, error, { onAuthFailed, onAuthRestored });
      }

      // 404 Not Found (S001 에러코드 제외)
      if (status === 404 && errorCode !== 'S001') {
        return handleAuthError(status, errorCode, error, { onAuthFailed, onAuthRestored });
      }

      // 401 Unauthorized
      if (status === 401) {
        return handleAuthError(status, errorCode, error, { onAuthFailed, onAuthRestored });
      }

      // 그 외 에러는 그대로 전달
      return Promise.reject(error);
    }
  );
};
```

### 3.2 AuthProvider.tsx (callback 수정)

```typescript
// src/contexts/AuthProvider.tsx

// ... (기존 코드)

// ------------------------------------------
// 마운트 시 인증 상태 확인 + Axios interceptor 설정
// ------------------------------------------
useEffect(() => {
  let mounted = true;

  // Axios interceptor 설정
  setupAxiosInterceptors({
    onAuthFailed: () => {
      // 인증 실패 → 로그인 페이지로
      handleLogout('세션이 만료되었습니다.');
    },
    onAuthRestored: () => {
      // 인증 복구 → WebSocket 재연결
      forceReconnect();
    },
  });

  // ... (나머지 코드)

  return () => {
    mounted = false;
  };
}, [handleLogout, forceReconnect, location.pathname]);

// ... (나머지 코드)
```

---

## 4. 핵심 변경사항 요약

### 4.1 변경 전 vs 변경 후

| 항목 | 변경 전 | 변경 후 |
|------|--------|--------|
| **플래그** | `isProcessing401`, `isProcessingError` (분리) | `isProcessingError` (통합) |
| **setTimeout** | 5초 대기 후 플래그 리셋 | **제거** |
| **에러 처리** | 401/403/404 각각 중복 코드 | `handleAuthError()` 공통 함수 |
| **에러 메시지** | 하드코딩 | 상태별 동적 결정 |
| **토스트 출력** | 중복 가능 | 한 번만 출력 |

### 4.2 setTimeout 제거 이유

```typescript
// ❌ 변경 전 (문제)
} catch {
  isProcessingError = false;
  isLoggingOut = true;
  onAuthFailed();
}

setTimeout(() => {           // 5초 후 플래그 리셋
  isProcessingError = false;
  isLoggingOut = false;
}, 5000);

// ✅ 변경 후
} catch {
  isProcessingError = false;  // 바로 리셋
  isLoggingOut = true;
  onAuthFailed();
  return Promise.reject(error);
}
```

**이유:**
1. 인증 FAIL 시 로그인 페이지로 이동 → 다시 인증 상태 확인 필요
2. 5초 대기 중 다른 에러가 오면 중복 처리 문제

---

## 5. 테스트 케이스

| 케이스 | 예상 동작 |
|--------|----------|
| API 호출 중 세션 만료 (401) | showToast → 인증 재확인 → 로그인 페이지로 이동 |
| 접근 권한 없음 (403, A006 제외) | showToast → 인증 재확인 → 로그인 페이지로 이동 |
| A006 에러 발생 | showToast("본인의 기기만...") → 에러만 reject |
| 인증 상태에서 탭 포커스 | 인증 재확인 → 유효하면 진행, 무효면 로그아웃 |
| 인증 OK 상태에서 403 발생 | showToast → 인증 재확인 → 요청 재진행 |

---

## 6. 구현 체크리스트

- [x] `isProcessing401` → `isProcessingError` 통합
- [x] `setTimeout` 제거
- [x] `handleAuthError()` 공통 함수 생성
- [x] `on401` → `onAuthFailed` 이름 변경
- [x] 빌드 확인
