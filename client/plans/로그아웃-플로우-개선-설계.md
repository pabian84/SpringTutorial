# 로그아웃 플로우 개선 설계

## 1. 현재 구현 분석

### 1.1 현재 코드

```typescript
const logout = useCallback(async (reason?: string) => {
    // 1. 먼저 WebSocket 닫기
    forceDisconnect();

    // 2. 토스트 및 상태 정리
    if (reason) showToast(reason, 'error');
    setAuthState({ authenticated: false, user: null, loading: false });
    resetAuthCheck();
    localStorage.clear();

    // 3. 서버 로그아웃 API 호출 (기다림)
    try {
        await userApi.logout(undefined);  // ⚠️ 여기서 무한 대기 가능
    } catch (e) {
        devLog('[AuthProvider] 로그아웃 API 오류:', e);
    }

    // 4. 로그인 페이지로 이동
    navigate('/', { replace: true });

    devLog('[AuthProvider] 로그아웃 완료');
}, [navigate, forceDisconnect]);
```

### 1.2 문제점

| 문제 | 설명 |
|------|------|
| **무한 대기** | 서버 응답이 없으면 `navigate`가 실행되지 않음 |
| **race condition** | `checkAuthStatus()`가 `/api/auth/check`를 호출할 수 있음 |
| **UX 저하** | 사용자가 로그인 페이지로 이동하지 못함 |

## 2. 권장 개선안: 타임아웃 적용

### 2.1 설계

```typescript
const LOGOUT_TIMEOUT = 3000; // 3초 타임아웃

const logout = useCallback(async (reason?: string) => {
    // 1. 먼저 WebSocket 닫기
    forceDisconnect();

    // 2. 토스트 및 상태 정리
    if (reason) showToast(reason, 'error');
    setAuthState({ authenticated: false, user: null, loading: false });
    resetAuthCheck();
    localStorage.clear();

    // 3. 서버 로그아웃 API 호출 (타임아웃 적용)
    const logoutPromise = userApi.logout(undefined);
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Logout timeout')), LOGOUT_TIMEOUT);
           await Promise.race([logoutPromise });

    try {
, timeoutPromise]);
        devLog('[AuthProvider] 로그아웃 API 완료');
    } catch (e) {
        // 타임아웃 또는 에러: 조용히 무시
        devLog('[AuthProvider] 로그아웃 타임아웃 또는 에러:', e);
    }

    // 4. 로그인 페이지로 이동 (항상 실행)
    navigate('/', { replace: true });

    devLog('[AuthProvider] 로그아웃 완료');
}, [navigate, forceDisconnect]);
```

### 2.2 플로우 다이어그램

```mermaid
flowchart TD
    A[로그아웃 시작] --> B[WebSocket 닫기]
    B --> C[로컬 상태 정리]
    C --> D[서버 로그아웃<br/>+ 타임아웃 3초]
    
    D --> E{완료?}
    E -->|API 먼저| F[navigate('/')]
    E -->|타임아웃 먼저| G[로그 출력<br/>조용히 무시]
    G --> F
    
    F --> H[로그아웃 완료]
```

## 3. 대안: Fire-and-Forget

### 3.1 설계 (더 간단함)

```typescript
const logout = useCallback(async (reason?: string) => {
    // 1. 먼저 WebSocket 닫기
    forceDisconnect();

    // 2. 토스트 및 상태 정리
    if (reason) showToast(reason, 'error');
    setAuthState({ authenticated: false, user: null, loading: false });
    resetAuthCheck();
    localStorage.clear();

    // 3. 서버 로그아웃 (기다리지 않음)
    userApi.logout(undefined).catch(e => {
        devLog('[AuthProvider] 로그아웃 백그라운드 에러:', e);
    });

    // 4. 로그인 페이지로 이동 (즉시)
    navigate('/', { replace: true });

    devLog('[AuthProvider] 로그아웃 완료');
}, [navigate, forceDisconnect]);
```

### 3.2 장단점

| 방식 | 장점 | 단점 |
|------|------|------|
| **타임아웃** | 3초内有 응답하면 처리, 그 이후는 무시 | 코드가 복잡함 |
| **Fire-and-Forget** | 간단함, 항상 빠르게 이동 | 서버 응답 확인 불가 |

## 4. 권장: Fire-and-Forget

**이유**:
1. **UX가 중요**: 사용자는 빠르게 로그인 페이지로 이동해야 함
2. **로그아웃은 멱등성**: 여러 번 호출해도 문제는 없음
3. **서버가 처리**: 로그아웃 API는 결국 처리될 것임
4. ** race condition**: 이미 `authenticated = false`이므로 `checkAuthStatus()`가 호출되어도 문제 없음

### 4.1 race condition 재분석

```mermaid
sequenceDiagram
    participant User
    participant AuthProvider
    participant Axios
    participant Backend
    
    User->>AuthProvider: 로그아웃 버튼
    
    rect rgb(200, 255, 200)
        Note: Race condition이 있어도 OK
    end
    
    AuthProvider->>AuthProvider: authenticated = false
    AuthProvider->>Axios: userApi.logout() (기다리지 않음)
    AuthProvider->>AuthProvider: navigate('/')
    
    Note over AuthProvider: 로컬에서는 이미 로그아웃 상태
    
    par race condition 가능
        Axios->>Backend: POST /api/user/logout
        AuthProvider->>AuthProvider: checkAuthStatus() (location 변경)
        Axios->>Axios: 401 반환 (쿠키 삭제됨)
    or 정상 처리
        Backend->>Backend: 세션 삭제
        Backend-->>Axios: 200 OK
    end
    
    Note over User: 사용자는 이미 로그인 페이지
```

**결론**: `authenticated = false`이므로 어떤 순서로 처리되든 문제 없음

## 5. 최종 권장 코드

```typescript
const LOGOUT_TIMEOUT_MS = 3000; // 3초

const logout = useCallback(async (reason?: string) => {
    // 1. 먼저 WebSocket 닫기
    forceDisconnect();

    // 2. 토스트 표시
    if (reason) {
        showToast(reason, 'error');
    }

    // 3. 로컬 상태 정리 (먼저!)
    setAuthState({
        authenticated: false,
        user: null,
        loading: false,
    });

    // 4. 인증 확인 결과 리셋
    resetAuthCheck();

    // 5. 로컬 스토리지 선택적 정리
    const safeKeys = ['theme', 'language', 'sidebarState'];
    const allKeys = Object.keys(localStorage);
    allKeys.forEach(key => {
        if (!safeKeys.includes(key)) {
            localStorage.removeItem(key);
        }
    });

    // 6. 서버 로그아웃 (타임아웃 + 백그라운드)
    const logoutPromise = userApi.logout(undefined);
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Logout timeout')), LOGOUT_TIMEOUT_MS);
    });

    Promise.race([logoutPromise, timeoutPromise])
        .then(() => devLog('[AuthProvider] 로그아웃 API 성공'))
        .catch((e) => {
            // 타임아웃은 조용히 무시, 에러는 로그
            if (e.message !== 'Logout timeout') {
                devLog('[AuthProvider] 로그아웃 API 에러:', e);
            }
        });

    // 7. 로그인 페이지로 이동 (항상!)
    navigate('/', { replace: true });

    devLog('[AuthProvider] 로그아웃 완료');
}, [navigate, forceDisconnect]);
```

## 6. 예상 로그

```
[WebSocketProvider] WebSocket 강제 종료
[AuthProvider] 로그아웃 API 성공 (또는 타임아웃)
[AuthProvider] 로그아웃 완료
```

이 설계를 적용하시겠습니까?