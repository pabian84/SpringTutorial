# 인증 아키텍처 v2.0 설계 문서

## 1. 개요

### 1.1 배경
기존 인증 시스템의 복잡한 이벤트 기반 로직으로 인한 무한 루프 및 유지보수 어려움을 해결하기 위해 새로운 아키텍처 도입

### 1.2 목표
- 인증 로직의 단순화 및 중앙집중식 관리
- 페이지별 인증 필요 여부 분류
- 보안성 유지 및 실무 적용 가능한 수준 달성

---

## 2. 아키텍처 개요

### 2.1 전체 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                        브라우저 (Client)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    App.tsx                                │  │
│  │  (Route 관리 + AuthInterceptor 통합)                      │  │
│  └───────────────────────────────────────────────────────────┘  │
│                           ↓                                      │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              AuthInterceptor.tsx (신규)                    │  │
│  │  - Protected 페이지 이동 감지                               │  │
│  │  - /api/auth/check API 호출                               │  │
│  │  - 인증 결과에 따라 네비게이션 결정                         │  │
│  └───────────────────────────────────────────────────────────┘  │
│                           ↓                                      │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                  AuthProvider.tsx                          │  │
│  │  - 인증 상태 관리 (localStorage 미사용)                     │  │
│  │  - httpOnly 쿠키 기반 인증                                │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                       서버 (Spring Boot)                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                 /api/auth/check (신규)                    │  │
│  │  - httpOnly 쿠키에서 accessToken 읽기                     │  │
│  │  - JWT 검증 및 사용자 정보 반환                            │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 페이지 분류

### 3.1 Protected Pages (인증 필요)

| 경로 | 설명 | 인증 확인 |
|------|------|----------|
| `/dashboard` | 메인 대시보드 | ✅ API 호출 |
| `/devices` | 기기 관리 | ✅ API 호출 |
| `/user/:userId` | 사용자 상세 | ✅ API 호출 |
| `/cesium` | 3D 지구 | ✅ API 호출 |
| `/threejs` | 3D 로봇 | ✅ API 호출 |

### 3.2 Public Pages (인증 불필요)

| 경로 | 설명 | 인증 확인 |
|------|------|----------|
| `/` | 로그인 페이지 | ❌ 바로 이동 |
| `/weather` | 날씨 상세 | ❌ 바로 이동 |

---

## 4. 컴포넌트 상세 설계

### 4.1 AuthInterceptor.tsx (신규 생성)

```typescript
// src/components/AuthInterceptor.tsx

import { useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { checkAuthStatus } from '../utils/authUtility';
import { showToast } from '../utils/Alert';

// Protected Pages 목록
const PROTECTED_PAGES = [
  '/dashboard',
  '/devices',
  '/cesium',
  '/threejs',
];

export function AuthInterceptor({ children }: { children: React.ReactNode }) {
  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    // Public Pages는 인증 확인 건너뛰기
    const isPublicPage = !PROTECTED_PAGES.some(page => 
      location.pathname.startsWith(page)
    );
    
    if (isPublicPage) {
      return;
    }

    // Protected Pages: 인증 확인
    checkAuthStatus()
      .then(result => {
        if (!result.authenticated) {
          showToast('로그인이 필요합니다.', 'error');
          navigate('/', { replace: true });
        }
      })
      .catch(() => {
        showToast('인증 확인 중 오류가 발생했습니다.', 'error');
        navigate('/', { replace: true });
      });
  }, [location.pathname, navigate]);

  return <>{children}</>;
}
```

### 4.2 App.tsx (변경)

```typescript
// src/App.tsx

import { Routes, Route } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthProvider';
import { AuthInterceptor } from './components/AuthInterceptor';
import { WebSocketProvider } from './contexts/WebSocketProvider';

// Pages
import Login from './pages/Login';
import Dashboard from './pages/Dashboard';
import WeatherDetail from './pages/WeatherDetail';
import CesiumDetail from './pages/CesiumDetail';
import ThreeJsDetail from './pages/ThreeJsDetail';
import DeviceManagement from './pages/DeviceManagement';
import UserDetail from './pages/UserDetail';

function App() {
  return (
    <AuthProvider>
      <WebSocketProvider>
        <AuthInterceptor>
          <Routes>
            {/* Public Routes */}
            <Route path="/" element={<Login />} />
            <Route path="/weather" element={<WeatherDetail />} />

            {/* Protected Routes (AuthInterceptor에서 인증 확인) */}
            <Route path="/dashboard" element={<Dashboard />} />
            <Route path="/devices" element={<DeviceManagement />} />
            <Route path="/user/:userId" element={<UserDetail />} />
            <Route path="/cesium" element={<CesiumDetail />} />
            <Route path="/threejs" element={<ThreeJsDetail />} />
          </Routes>
        </AuthInterceptor>
      </WebSocketProvider>
    </AuthProvider>
  );
}

export default App;
```

### 4.3 authUtility.ts (변경)

```typescript
// src/utils/authUtility.ts

import axios from 'axios';
import { showToast } from './Alert';
import { userApi } from '../api/userApi';

// ============================================
// 인증 확인 (Singleton Pattern)
// ============================================

let authCheckPromise: Promise<{ authenticated: boolean; user?: UserInfo }> | null = null;
let authCheckResult: { authenticated: boolean; user?: UserInfo } | null = null;

interface UserInfo {
  id: string;
  name: string;
}

/**
 * 인증 상태 확인 API 호출
 * - 한 번만 호출하고 결과를 캐싱
 * - 로그아웃 시 resetAuthCheck() 호출 필요
 */
export const checkAuthStatus = async (): Promise<{ authenticated: boolean; user?: UserInfo }> => {
  if (authCheckResult !== null) {
    return authCheckResult;
  }

  if (authCheckPromise !== null) {
    return authCheckPromise;
  }

  authCheckPromise = axios.get('/api/auth/check')
    .then(response => {
      const result = {
        authenticated: true,
        user: response.data.user as UserInfo
      };
      authCheckResult = result;
      return result;
    })
    .catch(error => {
      if (error.response?.status === 401) {
        authCheckResult = { authenticated: false };
        return authCheckResult;
      }
      authCheckResult = { authenticated: false };
      return authCheckResult;
    })
    .finally(() => {
      authCheckPromise = null;
    });

  return authCheckPromise;
};

/**
 * 인증 확인 결과 리셋
 */
export const resetAuthCheck = (): void => {
  authCheckPromise = null;
  authCheckResult = null;
};

// ============================================
// 로그아웃
// ============================================

export const logout = async (reason?: string): Promise<void> => {
  // 1. 토스트 표시
  if (reason) {
    showToast(reason, 'error');
  }

  // 2. 인증 확인 결과 리셋
  resetAuthCheck();

  // 3. 로컬 스토리지 정리
  const safeKeys = ['theme', 'language', 'sidebarState'];
  Object.keys(localStorage).forEach(key => {
    if (!safeKeys.includes(key)) {
      localStorage.removeItem(key);
    }
  });

  // 4. 서버 로그아웃 API 호출
  try {
    await userApi.logout();
  } catch (e) {
    console.error('로그아웃 API 오류:', e);
  }
};
```

---

## 5. 서버 사이드

### 5.1 AuthController.java (신규)

```java
package com.example.demo.domain.auth.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    /**
     * 인증 상태 확인
     * - httpOnly 쿠키에서 accessToken 읽기
     * - JWT 검증 및 사용자 정보 반환
     */
    @GetMapping("/check")
    public ResponseEntity<?> checkAuth(@AuthenticationPrincipal UserDetails userDetails) {
        if (userDetails == null) {
            return ResponseEntity.status(401).body(Map.of(
                "authenticated", false
            ));
        }

        return ResponseEntity.ok(Map.of(
            "authenticated", true,
            "user", Map.of(
                "id", userDetails.getUsername()
            )
        ));
    }
}
```

---

## 6. 보안 검토

### 6.1 보안 강점

| 항목 | 상태 | 설명 |
|------|------|------|
| 토큰 저장 | ✅ | httpOnly 쿠키 사용 (XSS 방지) |
| 인증 확인 | ✅ | 서버 사이드 검증 |
| 세션 관리 | ✅ | 서버에서 세션 관리 |
| 접근 제어 | ✅ | 페이지별 인증 확인 |

### 6.2 잠재적 위험

| 항목 | 위험도 | 완화 방안 |
|------|--------|----------|
| CSRF | 낮음 | SameSite 쿠키 설정 |
| 토큰 탈취 | 낮음 | httpOnly + Secure 쿠키 |

---

## 7. 성능 고려사항

### 7.1 Protected Pages

- **장점:** 보안성 높음
- **단점:** 페이지 이동 시 API 호출로 인한 지연 (약 100-200ms)

### 7.2 Public Pages

- **장점:** 빠른 이동
- **단점:** 별도 인증 확인 없음

---

## 8. 테스트 체크리스트

### 8.1 기능 테스트

- [ ] Protected 페이지 미로그인 시 로그인 페이지 리다이렉트
- [ ] Protected 페이지 로그인 후 접근 가능
- [ ] Public 페이지 로그인/미로그인 관계없이 접근 가능
- [ ] 로그아웃 후 Protected 페이지 접근 불가

### 8.2 보안 테스트

- [ ] httpOnly 쿠키 작동 확인
- [ ] 토큰 만료 시 자동 로그아웃
- [ ] API 인증 실패 시 적절한 에러 처리

---

## 9. 마이그레이션 계획

### 9.1 제거 대상

| 파일/컴포넌트 | 이유 |
|-------------|------|
| `GlobalLogoutHandler` | 인증Interceptor로 통합 |
| `GlobalNavigateHandler` | 인증Interceptor로 통합 |
| `SocketEventHandler` | 불필요한 복잡성 제거 |
| ProtectedRoute 컴포넌트 | 인증Interceptor로 대체 |

### 9.2 신규 생성

| 파일 | 역할 |
|------|------|
| `AuthInterceptor.tsx` | 전역 인증 가로채기 |
| `AuthController.java` | `/api/auth/check` 엔드포인트 |

---

## 10. 결론

이 아키텍처는:
- ✅ **단순성:** 중앙집중식 인증 관리
- ✅ **보안성:** 서버 사이드 인증 확인
- ✅ **유지보수성:** 명확한 코드 구조
- ✅ **실무 적용:** 대형 SPA에서 검증된 패턴

현재 프로젝트에 적합하며, 향후 확장에도 유연하게 대응 가능
