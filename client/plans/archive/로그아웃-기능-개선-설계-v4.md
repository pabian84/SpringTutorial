# UserController.logout 개선 설계 (v4) - 최종

## 1. 핵심 원칙

**UserController.logout은 "내 로그아웃"만 처리한다.**
- 다른 기기의 세션을 삭제/끊는 것은 이 곳에서 다루지 않는다.
- WebSocket 끊은 것은 Backend + Frontend 두 곳에서 처리 (이중 보장)

## 2. 개선 설계

### 2.1 Backend: UserController.logout

```java
@PostMapping("/logout")
public ResponseEntity<?> logout(@RequestBody(required = false) Map<String, String> body, 
                                  HttpServletRequest request, HttpServletResponse response) {
    String userId = null;
    Long sessionId = null;
    String token = jwtTokenProvider.resolveToken(request);
    
    // body에서 userId 우선 사용 (토큰 만료 시)
    if (body != null && body.containsKey("userId")) {
        userId = body.get("userId");
    }
    
    // 토큰이 유효하면 sessionId 추출
    if (token != null && jwtTokenProvider.validateToken(token)) {
        sessionId = jwtTokenProvider.getSessionId(token);
        if (userId == null) {
            userId = jwtTokenProvider.getAuthentication(token).getName();
        }
    }
    
    if (userId != null) {
        String userAgent = request.getHeader("User-Agent");
        String ipAddress = request.getRemoteAddr();
        
        if (sessionId != null) {
            // ✅ 정상 로그아웃: 해당 세션만 삭제
            userService.logout(userId, sessionId, userAgent, ipAddress);
            
            // ✅ WebSocket 끊기 (Backend: sessionId 기반)
            sessionService.forceDisconnectBySessionId(sessionId);
            
            log.info("로그아웃: userId={}, sessionId={}", userId, sessionId);
        } else {
            // ⚠️ sessionId가 없는 경우 (토큰 없음/만료)
            // 전체 삭제하지 않음!
            
            log.warn("로그아웃 요청: sessionId 없음, userId={}", userId);
            // ⚠️ WebSocket은 Backend에서 끊지 않음 (sessionId를 모르니까)
        }
    }
    
    // 쿠키 삭제
    boolean isHttps = "https".equalsIgnoreCase(request.getScheme());
    ResponseCookie accessCookie = cookieUtil.deleteCookie("accessToken", isHttps);
    response.addHeader("Set-Cookie", accessCookie.toString());

    return ResponseEntity.ok().body("로그아웃 되었습니다.");
}
```

### 2.2 Backend: SessionService.forceDisconnectBySessionId

```java
/**
 * 특정 sessionId로 WebSocket 강제 종료
 * (sessionId 기반으로 정확한 세션만 끊음)
 */
public void forceDisconnectBySessionId(Long sessionId) {
    // 현재 접속 중인 모든 세션에서 해당 sessionId 찾기
    for (Map.Entry<String, Set<WebSocketSession>> entry : webSocketSessionsMap.entrySet()) {
        String userId = entry.getKey();
        Set<WebSocketSession> sessions = entry.getValue();
        
        for (WebSocketSession session : sessions) {
            Long sId = (Long) session.getAttributes().get("sessionId");
            if (sId != null && sId.equals(sessionId)) {
                try {
                    log.info("WebSocket 강제 종료: userId={}, sessionId={}", userId, sessionId);
                    session.close(new CloseStatus(4001, "Logout"));
                } catch (Exception e) {
                    log.error("WebSocket 종료 중 에러", e);
                }
                return; // 하나 찾으면 종료
            }
        }
    }
    log.debug("WebSocket 세션 찾기 실패: sessionId={}", sessionId);
}
```

### 2.3 Frontend: AuthProvider.logout에서 WebSocket 닫기

```typescript
// AuthProvider.tsx
const logout = useCallback(async (reason?: string) => {
    // ✅ 먼저 WebSocket 닫기 (Frontend에서)
    if (socketRef.current) {  // WebSocketProvider의 ref 필요
        socketRef.current.close();
    }

    // 토스트 표시
    if (reason) {
        showToast(reason, 'error');
    }

    // 로컬 상태 정리
    setAuthState({
        authenticated: false,
        user: null,
        loading: false,
    });

    // 인증 확인 결과 리셋
    resetAuthCheck();

    // 서버 로그아웃 API 호출
    try {
        await userApi.logout(undefined);
    } catch (e) {
        devLog('[AuthProvider] 로그아웃 API 오류:', e);
    }

    // 로그인 페이지로 이동
    navigate('/', { replace: true });

    devLog('[AuthProvider] 로그아웃 완료');
}, [navigate]);
```

**하지만 AuthProvider에는 socketRef가 없음.** WebSocketProvider에서 처리해야 함.

### 2.4 대안: Frontend에서 useWebSocket을 통해 WebSocket 닫기

```typescript
// AuthProvider.tsx
const { forceDisconnect } = useWebSocket();  // 새로운 함수 추가

const logout = useCallback(async (reason?: string) => {
    // ✅ 먼저 WebSocket 닫기 (Frontend에서)
    forceDisconnect();  // WebSocketProvider의 함수 호출

    // ... 기존 로직 ...
}, [navigate, forceDisconnect]);
```

**WebSocketProvider에 `forceDisconnect()` 함수 추가 필요:**

```typescript
// WebSocketProvider.tsx
const forceDisconnect = useCallback(() => {
    if (socketRef.current) {
        socketRef.current.close();
        socketRef.current = null;
        setIsConnected(false);
    }
    isLoggedOutRef.current = true;  // 재연결 방지
}, []);
```

## 3. 전체 플로우 (이중 보장)

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant WebSocket
    participant DB
    
    Note over User,DB: 로그아웃 시 WebSocket 이중 끊기
    
    User->>Frontend: 로그아웃 버튼 클릭
    
    rect rgb(144, 238, 144)
        Note: 1. Frontend에서 먼저 WebSocket 닫기
    end
    
    Frontend->>Frontend: socketRef.current.close()
    Frontend->>Frontend: navigate('/')
    
    rect rgb(255, 200, 200)
        Note: 2. Backend에서도 WebSocket 닫기 (이중 보장)
    end
    
    Frontend->>Backend: POST /api/user/logout
    Backend->>Backend: sessionId 추출
    Backend->>DB: deleteSession(sessionId)
    DB-->>Backend: 삭제 완료
    
    Backend->>WebSocket: forceDisconnectBySessionId(sessionId)
    WebSocket-->>Backend: 연결 종료
    
    Backend-->>Frontend: 200 OK
    
    Note over Frontend,WebSocket: ⚠️ 두 곳에서 WebSocket을 닫으므로<br/>어느 한쪽이 실패해도 괜찮음
```

## 4. 세션 삭제 로그 추가

### 4.1 UserService.logout()

```java
public void logout(String userId, Long sessionId, String userAgent, String ipAddress) {
    // DB에서 세션 삭제
    sessionMapper.deleteBySessionId(sessionId);
    
    // ✅ 로그 추가
    log.info("세션 삭제됨: userId={}, sessionId={}, device={}, ip={}", 
             userId, sessionId, userAgent, ipAddress);
    
    // 로그 기록
    accessLogService.saveLog(userId, sessionId, 
                            SecurityConstants.TYPE_LOGOUT, null, null, ipAddress, userAgent);
}
```

### 4.2 SessionService.forceDisconnectBySessionId()

```java
public void forceDisconnectBySessionId(Long sessionId) {
    for (Map.Entry<String, Set<WebSocketSession>> entry : webSocketSessionsMap.entrySet()) {
        String userId = entry.getKey();
        Set<WebSocketSession> sessions = entry.getValue();
        
        for (WebSocketSession session : sessions) {
            Long sId = (Long) session.getAttributes().get("sessionId");
            if (sId != null && sId.equals(sessionId)) {
                try {
                    log.info("WebSocket 강제 종료: userId={}, sessionId={}", userId, sessionId);
                    session.close(new CloseStatus(4001, "Logout"));
                } catch (Exception e) {
                    log.error("WebSocket 종료 중 에러", e);
                }
                return;
            }
        }
    }
}
```

## 5. 변경 파일 요약

### 5.1 Backend 변경

| 파일 | 변경 내용 |
|------|----------|
| `UserController.java` | sessionId 없으면 logoutAll 호출 제거, forceDisconnectBySessionId 호출 추가 |
| `SessionService.java` | forceDisconnectBySessionId() 메서드 추가 |
| `UserService.java` | logout()에 로그 추가 |

### 5.2 Frontend 변경

| 파일 | 변경 내용 |
|------|----------|
| `WebSocketProvider.tsx` | forceDisconnect() 함수 추가 |
| `AuthProvider.tsx` | logout()에서 forceDisconnect() 호출 추가 |

## 6. 예상 로그 출력

### 정상 로그아웃

```
[Frontend] WebSocket 닫기
[Backend] 세션 삭제됨: userId=hong, sessionId=993, device=Chrome, ip=0:0:0:0:0:0:0:1
[Backend] WebSocket 강제 종료: userId=hong, sessionId=993
[Backend] 로그아웃: userId=hong, sessionId=993
```

### sessionId 없는 경우

```
[Frontend] WebSocket 닫기
[Backend] 로그아웃 요청: sessionId 없음, userId=hong
```

이 설계로 진행하시겠습니까?