# 🛠️ 프로젝트 유지보수 최적화 및 리팩토링 가이드

## 1. 아키텍처 진단: 파편화의 원인
- **백엔드(Server)**: 소규모 기능(날씨, 메모 등)임에도 독립된 패키지 구조가 과도하게 세분화되어 반복 코드가 많음.
- **프론트엔드(Client)**:
    - **Context 과다**: 데이터 흐름 추적이 어렵고 Provider Depth가 깊음.
    - **인증 로직의 분산**: AuthProvider, authUtility, axiosConfig 간의 상태 동기화 충돌.
    - **UI 결합**: API 에러 처리 로직에 토스트(UI)가 강하게 결합됨.

---

## 2. 프론트엔드(Client) 리팩토링 전략

### 2.1 Context 및 상태 관리 통합 (Consolidation)
- **`AuthContext` + `UserContext`**: 사용자의 기본 정보와 인증 상태를 하나의 컨텍스트에서 관리.
- **`DashboardContext`**: `UserLocation`, `CesiumCamera` 등 대시보드 표시와 관련된 상태를 통합하여 의존성 해결.

### 2.2 인증 로직의 단일화 (Hybrid Sync Architecture)
- **통신 계층 (Promise Lock)**: `authUtility.ts`에서 단일 `Promise` 변수를 사용하여 동시 다발적인 인증 확인 요청을 하나로 수렴.
- **참조 계층 (Ref Sync)**: API 응답 즉시 `isAuthenticatedRef.current`를 업데이트하여 React의 상태 업데이트 지연(Gap) 해결.
- **UI 계층 (State Update)**: `AuthProvider`는 유틸리티의 결과를 받아 UI만 업데이트하도록 역할 분리.

### 2.3 파일별 리팩토링 세부 지침
1. **authUtility.ts**:
   - `isLoggingIn/Out` 플래그 관리 및 `checkAuthStatus`의 Promise Locking 구현.
   - `axios` 대신 인터셉터가 없는 `pureAxios` 혹은 `fetch`를 고려하여 무한 루프 방지.
2. **AuthProvider.tsx**:
   - `login/logout` 로직 내의 중복된 상태 업데이트 로직을 `syncAuthState` 함수로 통합.
   - 불필요한 `useEffect` 의존성 제거 및 초기 마운트 시 로직 간소화.
3. **axiosConfig.ts**:
   - 401 에러 발생 시 `handleAuthError`가 `authUtility`의 잠금 기능을 활용하도록 수정.
   - 요청 큐(Retry Queue) 관리 로직을 단순화하여 메모리 누수 방지.

---

## 3. 백엔드(Server) 리팩토링 전략

### 3.1 도메인 계층 최적화 (Domain Consolidation)
- **`domain.widget` (통합)**: `weather`, `memo`, `finance`, `stats` 등을 하나의 위젯 도메인으로 병합하여 보일러플레이트 제거.
- **`domain.member`**: `user`와 `auth` 패키지를 통합.

### 3.2 Service 레이어의 간소화
- **Interface/Impl 분리 제거**: 구현체가 하나인 경우 클래스 하나로 작성하여 파일 수 절감.
- **공통 Mapper 도입**: 반복적인 DTO-Entity 변환 로직을 제네릭하게 처리하거나 라이브러리 활용.

---

## 4. 단계별 실행 로드맵
1. **1단계 (인증 단순화)**: 중복 호출 방지 및 상태 전이 로직 확립.
2. **2단계 (프론트 구조 정리)**: Context 통합 및 폴더 구조 체계화.
3. **3단계 (백엔드 도메인 병합)**: 위젯 관련 도메인 통합 패키지화.
4. **4단계 (환경 설정)**: 하드코딩된 설정을 환경 변수로 분리.
